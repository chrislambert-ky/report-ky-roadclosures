<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-468B94S87K"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-468B94S87K');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis of KY Road Closures: Map</title>
    <!-- My stylesheet for this page -->
    <link rel="stylesheet" href="../css/analysis_by_map.css">
    <!-- Required Leaflet CSS for mapping -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <!-- MarkerCluster plugin CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
    <!-- Required Leaflet JS for mapping -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- MarkerCluster plugin JS -->
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
</head>
<body>
    <nav class="main-nav">
        <a class="nav-link" href="../index.html">Home</a>
        <a class="nav-link" href="analysis_by_count.html">Analysis by Count</a>
        <a class="nav-link" href="analysis_by_duration.html">Analysis by Duration</a>
        <a class="nav-link" href="analysis_by_map.html">Map View</a>
        <a class="nav-link" href="analysis_by_table.html">Table View</a>
        <a class="nav-link" href="powerbi.html">Power BI Dashboard</a>
        <a class="nav-link" href="about.html">About</a>
    </nav>
    <div style="text-align: center;">
        <h1>Interactive Analysis of KY Road Closures: by Location</h1>
        <h2>Data refreshes daily 12:30am EST</h2>
    </div>


<div style="text-align: center;">
  <!-- Center filter controls to match the map width (800px) -->
  <div class="dropdown-filter-menus">
    <div class="filter-row filter-row--primary">
      <div class="filter-cell">
        <label class="filter-label" for="districtFilterSelect">District</label>
        <select id="districtFilterSelect" class="filter-select filter-select--narrow"></select>
      </div>
      <div class="filter-cell">
        <label class="filter-label" for="countyFilter">County</label>
        <select id="countyFilter" class="filter-select filter-select--wide">
          <option value="">All Counties</option>
        </select>
      </div>
      <div class="filter-cell">
        <label class="filter-label" for="routeFilterSelect">Route Prefix</label>
        <select id="routeFilterSelect" class="filter-select filter-select--wide">
          <option value="">All Routes</option>
        </select>
      </div>
    </div>
    <div class="filter-row filter-row--secondary">
      <div class="filter-cell">
        <label class="filter-label" for="yearFilterSelect">Year</label>
        <select id="yearFilterSelect" class="filter-select filter-select--narrow"></select>
      </div>
      <div class="filter-cell filter-cell--toggle">
        <label class="filter-toggle" for="enableClustering">
          <input id="enableClustering" type="checkbox"> Enable Clustering
        </label>
      </div>
      <div class="filter-cell filter-cell--action">
        <button id="refreshDataBtn" class="filter-button filter-button--primary">Refresh Data</button>
      </div>
      <div class="filter-cell filter-cell--action">
        <button id="clearFiltersBtn" class="filter-button filter-button--secondary">Clear</button>
      </div>
    </div>
    <script src="../js/idb_data_loader.js"></script>
    <script>
  // --- Dynamic Dropdowns and Map Filtering ---
  // These variables will be used by the main script as well
  let allData = [];
  let filteredData = [];

  // Use shared IDB module - loadData and refreshData are now available globally

  async function loadDataAndInit() {
    // Use shared loadData function with callbacks for custom initialization
    return loadData({
      onStatusUpdate: updateDataStatus,
      onDataReady: function(data) {
        allData = data;
        filteredData = allData;
        updateDropdowns();
        scheduleUpdateMapMarkers();
        attachFilterHandlers();
        buildLegend(getUnique(allData, item => getYear(item.Reported_On)));
      }
    }).catch(err => {
      console.error('Data initialization failed', err);
      updateDataStatus({ source: 'error', message: String(err) });
    });
  }

  function updateDataStatus(info) {
    const el = document.getElementById('dataStatus');
    if (!el) return;
    // Use the message from shared module which includes lastFetched timestamp
    el.textContent = info.message || '';
  }

  function attachFilterHandlers() {
    const countyEl = document.getElementById('countyFilter');
    if (countyEl && !countyEl._attached) {
  countyEl.addEventListener('change', function(){ onFilterChange(); scheduleUpdateMapMarkers(); });
      countyEl._attached = true;
    }
    const routeSelect = document.getElementById('routeFilterSelect');
    if (routeSelect && !routeSelect._attached) {
      routeSelect.addEventListener('change', function() {
        const routeHidden = document.getElementById('routeFilterValue');
        if (routeHidden) routeHidden.value = this.value || '';
        onFilterChange();
        scheduleUpdateMapMarkers();
      });
      routeSelect._attached = true;
    }
    const clearBtn = document.getElementById('clearFiltersBtn');
    if (clearBtn && !clearBtn._attached) {
      clearBtn.addEventListener('click', function() {
        document.getElementById('yearFilterValue').value = '';
        document.getElementById('districtFilterValue').value = '';
        document.getElementById('countyFilter').value = '';
        const routeHidden = document.getElementById('routeFilterValue');
        if (routeHidden) routeHidden.value = '';
        if (routeSelect) routeSelect.value = '';
        filterData();
        updateDropdowns();
        scheduleUpdateMapMarkers();
      });
      clearBtn._attached = true;
    }
    const clusterToggle = document.getElementById('enableClustering');
    if (clusterToggle && !clusterToggle._attached) {
      clusterToggle.addEventListener('change', function() {
        // Re-render markers using the new clustering preference (debounced)
        scheduleUpdateMapMarkers(150);
      });
      clusterToggle._attached = true;
    }
    const yearSelect = document.getElementById('yearFilterSelect');
    if (yearSelect && !yearSelect._attached) {
      yearSelect.addEventListener('change', function() {
        document.getElementById('yearFilterValue').value = this.value || '';
        onFilterChange();
        scheduleUpdateMapMarkers();
      });
      yearSelect._attached = true;
    }
    const districtSelect = document.getElementById('districtFilterSelect');
    if (districtSelect && !districtSelect._attached) {
      districtSelect.addEventListener('change', function() {
        document.getElementById('districtFilterValue').value = this.value || '';
        onFilterChange();
        scheduleUpdateMapMarkers();
      });
      districtSelect._attached = true;
    }
    const refreshBtn = document.getElementById('refreshDataBtn');
    if (refreshBtn && !refreshBtn._attached) {
      refreshBtn.addEventListener('click', async function() {
        refreshBtn.disabled = true;
        const orig = refreshBtn.textContent;
        refreshBtn.textContent = 'Refreshing...';
        try {
          // Use shared refreshData function
          const data = await refreshData(updateDataStatus);
          allData = data;
          filteredData = allData;
          updateDropdowns();
          scheduleUpdateMapMarkers();
        } catch (err) {
          console.warn('Refresh failed', err);
          updateDataStatus({ source: 'error', message: String(err) });
        }
        refreshBtn.textContent = orig;
        refreshBtn.disabled = false;
      });
      refreshBtn._attached = true;
    }
  }

  // Add chunked marker addition to avoid blocking the main thread when adding many markers
  function yearColor(year) {
    const palette = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'];
    const idx = (parseInt(year,10) || 0) % palette.length;
    return palette[idx];
  }

  function chunkedAddMarkers(closures, chunkSize = 400, delay = 20) {
    // closures: array of closure objects already deduplicated
    window.nonClusterMarkers = window.nonClusterMarkers || [];
    let i = 0;
    function work() {
      const end = Math.min(i + chunkSize, closures.length);
      for (; i < end; i++) {
        const closure = closures[i];
        const lat = parseFloat(closure.latitude);
        const lon = parseFloat(closure.longitude);
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          const clusterEnabled = document.getElementById('enableClustering') && document.getElementById('enableClustering').checked;
          const content = `<b>${closure.Road_Name}</b><br>` +
            `${closure.Comments}<br>` +
            `<b>County:</b> ${closure.County_Name}<br>` +
            `<b>Reported:</b> ${closure.Reported_On}<br>` +
            `<b>Duration (hrs):</b> ${closure.Duration_Hours}`;
          if (clusterEnabled) {
            const marker = L.marker([lat, lon]);
            marker.on('click', function(e) { if (!this.getPopup()) this.bindPopup(content).openPopup(); });
            markerClusterGroup.addLayer(marker);
          } else {
            const yr = getYear(closure.Reported_On) || '0';
            const color = yearColor(yr);
            const marker = L.circleMarker([lat, lon], { radius: 5, color: '#333', weight: 1, fillColor: color, fillOpacity: 0.85 });
            marker.on('click', function(e) { if (!this.getPopup()) this.bindPopup(content).openPopup(); });
            marker.addTo(map);
            window.nonClusterMarkers.push(marker);
          }
        }
      }
      if (i < closures.length) {
        setTimeout(work, delay);
      } else {
        // finished
      }
    }
    work();
  }

  // Debounced update helper to avoid re-rendering rapidly during wheel/zoom
  let __updateTimer = null;
  function scheduleUpdateMapMarkers(delay = 200) {
    if (__updateTimer) clearTimeout(__updateTimer);
    __updateTimer = setTimeout(() => {
      updateMapMarkers();
      __updateTimer = null;
    }, delay);
  }
  // Debounced update helper to avoid re-rendering rapidly during wheel/zoom


  function getUnique(arr, keyFn) {
    return [...new Set(arr.map(keyFn))].sort();
  }

  function getYear(dateStr) {
    if (!dateStr) return '';
    const d = new Date(dateStr);
    return isNaN(d) ? '' : d.getFullYear().toString();
  }

  function normalizeCountyName(value) {
    if (value === undefined || value === null) return 'Unknown';
    const trimmed = String(value).trim();
    return trimmed || 'Unknown';
  }

  function normalizeRoutePrefix(value) {
    if (value === undefined || value === null) return 'Unknown';
    const trimmed = String(value).trim();
    return trimmed || 'Unknown';
  }

  function applyFilters(sourceData, options = {}) {
    const {
      excludeYear = false,
      excludeDistrict = false,
      excludeCounty = false,
      excludeRoute = false
    } = options;

    const yearValue = document.getElementById('yearFilterValue') ? document.getElementById('yearFilterValue').value : '';
    const districtValue = document.getElementById('districtFilterValue') ? document.getElementById('districtFilterValue').value : '';
    const countyValue = document.getElementById('countyFilter') ? document.getElementById('countyFilter').value : '';
    const routeValue = document.getElementById('routeFilterValue') ? document.getElementById('routeFilterValue').value : '';

    return sourceData.filter(item => {
      const itemYear = getYear(item.Reported_On);
      const itemDistrict = item.District_Number !== undefined && item.District_Number !== null ? String(item.District_Number) : 'Unknown';
      const itemCounty = normalizeCountyName(item.County_Name);
      const itemRoute = normalizeRoutePrefix(item.Route_Prefix);

      if (!excludeYear && yearValue && itemYear !== yearValue) return false;
      if (!excludeDistrict && districtValue && itemDistrict !== districtValue) return false;
      if (!excludeCounty && countyValue && itemCounty !== countyValue) return false;
      if (!excludeRoute && routeValue && itemRoute !== routeValue) return false;
      return true;
    });
  }

  function buildLegend(years) {
    const container = document.getElementById('legendContainer');
    if (!container) return;
    try {
      const uniq = Array.from(new Set(years.filter(Boolean))).sort();
      container.innerHTML = '';
      uniq.forEach(y => {
        const span = document.createElement('span');
        span.style.marginRight = '10px';
        const col = yearColor(y);
        span.innerHTML = `<span style="display:inline-block;width:12px;height:12px;background:${col};margin-right:6px;border:1px solid #333;"></span>${y}`;
        container.appendChild(span);
      });
    } catch (e) { /* noop */ }
  }

  function populateDropdown(id, options, label, baseData) {
    const select = document.getElementById(id);
    if (!select) return;
    if (id === 'countyFilter') {
      const data = Array.isArray(baseData) ? baseData : allData;
      const total = data.length;
      select.innerHTML = `<option value="">All ${label}${Number.isFinite(total) ? ` (${total})` : ''}</option>` +
        options.map(opt => {
          const count = data.filter(item => normalizeCountyName(item.County_Name) === opt).length;
          return `<option value="${opt}">${opt} (${count})</option>`;
        }).join('');
    } else {
      select.innerHTML = `<option value="">All ${label}</option>` +
        options.map(opt => `<option value="${opt}">${opt}</option>`).join('');
    }
  }

  function defaultOptionLabel(value, count, type) {
    if (type === 'district' || type === 'districtFilterSelect') {
      if (value === 'Unknown') return `Unknown (${count})`;
      return `District ${value} (${count})`;
    }
    return `${value} (${count})`;
  }

  // Populate a native <select> element with options
  function populateSelect(id, options, includeAllLabel, config = {}) {
    const sel = document.getElementById(id);
    if (!sel) return;
    const allLabel = includeAllLabel || 'All';
    const baseData = Array.isArray(config.baseData) ? config.baseData : allData;
    const optionType = config.optionType || id;
    sel.innerHTML = '';

    const first = document.createElement('option');
    first.value = '';
    const totalCount = Number.isFinite(config.allCount) ? config.allCount : baseData.length;
    first.textContent = Number.isFinite(totalCount) ? `${allLabel} (${totalCount})` : allLabel;
    sel.appendChild(first);

    options.forEach(opt => {
      const o = document.createElement('option');
      o.value = opt;
      let count = 0;
      switch (optionType) {
        case 'year':
        case 'yearFilterSelect':
          count = baseData.filter(item => getYear(item.Reported_On) === opt).length;
          break;
        case 'district':
        case 'districtFilterSelect':
          count = baseData.filter(item => {
            const districtValue = item.District_Number !== undefined && item.District_Number !== null ? String(item.District_Number) : 'Unknown';
            return districtValue === opt;
          }).length;
          break;
        case 'route':
        case 'routeFilterSelect':
          count = baseData.filter(item => normalizeRoutePrefix(item.Route_Prefix) === opt).length;
          break;
        default:
          count = baseData.filter(item => item === opt).length;
      }
      o.textContent = config.formatOption ? config.formatOption(opt, count) : defaultOptionLabel(opt, count, optionType);
      sel.appendChild(o);
    });
  }

  function populateMenu(id, options, selected, label) {
    // Backwards-compat: if an element with this id exists and is a select, populate that instead
    const el = document.getElementById(id);
    if (!el) return;
    if (el.tagName && el.tagName.toLowerCase() === 'select') {
      populateSelect(id, options, `All ${label}`);
      // select current value if available
      if (selected) el.value = selected;
      return;
    }
    // legacy nav-menu behavior
    const menu = el;
    menu.innerHTML = '';
    // Add "All" option
    const allBtn = document.createElement('a');
    allBtn.className = 'nav-link';
    allBtn.textContent = `All ${label}`;
    allBtn.style.cursor = 'pointer';
    if (!selected) {
      allBtn.style.background = 'var(--blue)';
      allBtn.style.color = '#fff';
    }
    allBtn.onclick = function() {
      menu.querySelectorAll('.nav-link').forEach(el => {
        el.style.background = '';
        el.style.color = '';
      });
      allBtn.style.background = 'var(--blue)';
      allBtn.style.color = '#fff';
      setFilter(id, '');
    };
    menu.appendChild(allBtn);
    options.forEach(opt => {
      const btn = document.createElement('a');
      btn.className = 'nav-link';
      btn.textContent = opt;
      btn.style.cursor = 'pointer';
      if (selected == opt) {
        btn.style.background = 'var(--blue)';
        btn.style.color = '#fff';
      }
      btn.onclick = function() {
        menu.querySelectorAll('.nav-link').forEach(el => {
          el.style.background = '';
          el.style.color = '';
        });
        btn.style.background = 'var(--blue)';
        btn.style.color = '#fff';
        setFilter(id, opt);
      };
      menu.appendChild(btn);
    });
  }

  function setFilter(menuId, value) {
    if (menuId === 'yearMenu') {
      document.getElementById('yearFilterValue').value = value;
    } else if (menuId === 'districtMenu') {
      document.getElementById('districtFilterValue').value = value;
    }
    onFilterChange();
  }

  function filterData(options = {}) {
    filteredData = applyFilters(allData, options);
    return filteredData;
  }

  function updateDropdowns() {
    const selectedYear = document.getElementById('yearFilterValue').value;
    const selectedDistrict = document.getElementById('districtFilterValue').value;
    const selectedCounty = document.getElementById('countyFilter').value;
    const selectedRoute = document.getElementById('routeFilterValue') ? document.getElementById('routeFilterValue').value : '';

    const yearBase = applyFilters(allData, { excludeYear: true });
    let yearSet = getUnique(yearBase, item => getYear(item.Reported_On)).filter(Boolean);
    if (selectedYear && !yearSet.includes(selectedYear)) yearSet.push(selectedYear);
    yearSet = yearSet.sort((a, b) => Number(a) - Number(b));

    const districtBase = applyFilters(allData, { excludeDistrict: true });
    let districtSet = getUnique(districtBase, item => item.District_Number !== undefined && item.District_Number !== null ? String(item.District_Number) : 'Unknown');
    if (selectedDistrict && !districtSet.includes(selectedDistrict)) districtSet.push(selectedDistrict);
    districtSet = districtSet.sort((a, b) => {
      if (a === 'Unknown') return 1;
      if (b === 'Unknown') return -1;
      return Number(a) - Number(b);
    });

    const countyBase = applyFilters(allData, { excludeCounty: true });
    let countySet = getUnique(countyBase, item => normalizeCountyName(item.County_Name));
    if (selectedCounty && !countySet.includes(selectedCounty)) countySet.push(selectedCounty);
    countySet = countySet.sort((a, b) => a.localeCompare(b));

    const routeBase = applyFilters(allData, { excludeRoute: true });
    let routeSet = getUnique(routeBase, item => normalizeRoutePrefix(item.Route_Prefix));
    if (selectedRoute && !routeSet.includes(selectedRoute)) routeSet.push(selectedRoute);
    routeSet = routeSet.sort((a, b) => a.localeCompare(b));

    populateMenu('yearMenu', yearSet, selectedYear, 'Years');
    populateMenu('districtMenu', districtSet, selectedDistrict, 'Districts');
    populateDropdown('countyFilter', countySet, 'Counties', countyBase);

    try {
      populateSelect('yearFilterSelect', yearSet, 'All Years', { optionType: 'year', baseData: yearBase });
      const ysel = document.getElementById('yearFilterSelect'); if (ysel) ysel.value = selectedYear || '';
    } catch (e) {}
    try {
      populateSelect('districtFilterSelect', districtSet, 'All Districts', { optionType: 'district', baseData: districtBase });
      const dsel = document.getElementById('districtFilterSelect'); if (dsel) dsel.value = selectedDistrict || '';
    } catch (e) {}
    try {
      populateSelect('routeFilterSelect', routeSet, 'All Routes', { optionType: 'route', baseData: routeBase });
      const rsel = document.getElementById('routeFilterSelect'); if (rsel) rsel.value = selectedRoute || '';
    } catch (e) {}
  }

  function updateMapMarkers() {
    // clear any existing non-cluster markers and cluster group
    if (window.nonClusterMarkers && window.nonClusterMarkers.length) {
      window.nonClusterMarkers.forEach(m => { try { map.removeLayer(m); } catch(e){} });
    }
    window.nonClusterMarkers = [];
    try { markerClusterGroup.clearLayers(); } catch (e) {}
    const selectedCounty = document.getElementById('countyFilter').value;
    // Always render non-clustered colored circle markers (clustering disabled)
    // Deduplicate by lat,lon,road,reported,comments
    const usedCoords = {};
    const uniqueClosures = [];
    (selectedCounty ? filteredData.filter(item => item.County_Name === selectedCounty) : filteredData).forEach(closure => {
      if (closure.latitude && closure.longitude) {
        const key = [closure.latitude, closure.longitude, closure.Road_Name, closure.Reported_On, closure.Comments].join('|');
        if (!usedCoords[key]) { usedCoords[key] = true; uniqueClosures.push(closure); }
      }
    });
    // Build legend from available years
    buildLegend(getUnique(uniqueClosures, item => getYear(item.Reported_On)));
    // Zoom/fit to selected county OR district extent if selected
    try {
      const selectedDistrict = document.getElementById('districtFilterValue').value;
      // If county selected, we already filtered uniqueClosures to county
      if ((selectedCounty || selectedDistrict) && uniqueClosures.length > 0) {
        const bounds = L.latLngBounds(uniqueClosures.map(c => [parseFloat(c.latitude), parseFloat(c.longitude)]).filter(p => Number.isFinite(p[0]) && Number.isFinite(p[1])));
        if (bounds.isValid() && bounds.getNorthEast() && bounds.getSouthWest()) {
          if (uniqueClosures.length === 1) {
            // single point: center and zoom in moderately
            const p = bounds.getCenter();
            map.setView(p, Math.max(map.getZoom(), 12));
          } else {
            map.fitBounds(bounds.pad(0.15));
          }
        }
      } else if (!selectedCounty && !selectedDistrict) {
        // no county or district selected: reset to default full-state view
        try { map.setView([37.822295, -85.76819], 7); } catch (e) { /* noop */ }
      } else if (selectedDistrict && uniqueClosures.length === 0) {
        // If district selected but there were no deduped closures (edge case), try to use all filteredData for district extents
        const districtItems = filteredData.filter(item => String(item.District_Number) === selectedDistrict && item.latitude && item.longitude);
        if (districtItems.length > 0) {
          const bounds = L.latLngBounds(districtItems.map(c => [parseFloat(c.latitude), parseFloat(c.longitude)]).filter(p => Number.isFinite(p[0]) && Number.isFinite(p[1])));
          if (bounds.isValid()) map.fitBounds(bounds.pad(0.15));
        }
      }
    } catch (e) { console.warn('Error fitting bounds', e); }

  // Use chunked renderer to add markers (clustered or non-clustered depending on toggle)
  chunkedAddMarkers(uniqueClosures);
  }

  function onFilterChange(e) {
    // Save current selections
    const prev = {
      year: document.getElementById('yearFilterValue').value,
      district: document.getElementById('districtFilterValue').value,
      county: document.getElementById('countyFilter').value,
      route: document.getElementById('routeFilterValue') ? document.getElementById('routeFilterValue').value : ''
    };
    filterData();
    updateDropdowns();
    // Restore previous selection if still valid
    document.getElementById('yearFilterValue').value = prev.year;
    document.getElementById('districtFilterValue').value = prev.district;
    document.getElementById('countyFilter').value = prev.county;
    const routeHidden = document.getElementById('routeFilterValue');
    if (routeHidden) routeHidden.value = prev.route;
    const routeSelect = document.getElementById('routeFilterSelect');
    if (routeSelect) routeSelect.value = prev.route;
    filterData(); // filter again in case dropdowns changed
    updateMapMarkers();
  }

  // Wait for DOM and map to be ready
  document.addEventListener('DOMContentLoaded', function() {
    // Add hidden inputs to store selected values
    if (!document.getElementById('yearFilterValue')) {
      const y = document.createElement('input');
      y.type = 'hidden';
      y.id = 'yearFilterValue';
      y.value = '';
      document.body.appendChild(y);
    }
    if (!document.getElementById('districtFilterValue')) {
      const d = document.createElement('input');
      d.type = 'hidden';
      d.id = 'districtFilterValue';
      d.value = '';
      document.body.appendChild(d);
    }
    if (!document.getElementById('routeFilterValue')) {
      const r = document.createElement('input');
      r.type = 'hidden';
      r.id = 'routeFilterValue';
      r.value = '';
      document.body.appendChild(r);
    }
    // Load data (try IndexedDB first, then network) and initialize the UI
    loadDataAndInit();
  });
    </script>
    </div>
</div>

    <div style="text-align: center; margin-top:8px;">
      <div id="legendContainer" style="margin-bottom:8px; max-width:800px; text-align:left; display:inline-block;"></div>
    </div>
    <div style="text-align: center;">
      <div id="map" style="width: 800px; height: 600px; display: inline-block;"></div>
    </div>
    <div style="text-align:center;margin-top:8px;font-size:0.95em;color:#333;">
      <span id="dataStatus">&nbsp;</span>
    </div>

<!-- perf panel removed -->

<script>

// Leaflet Map
// =============================
// The following Leaflet map is based on their Quick Start example.
// https://leafletjs.com/examples/quick-start/
// I just had to fetch my data and start customizing the content.
// The performance was horrible with 10,000+ individual markers
// I had to use the Leaflet.markercluster plugin.

// latitude, longitude, and zoom to center of Kentucky
const map = L.map('map').setView([37.822295, -85.76819], 7);

// Add OpenStreetMap tiles as the base map layer
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', 
{
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
}).addTo(map);

// Create marker cluster group (used when clustering enabled)
let markerClusterGroup = L.markerClusterGroup({ maxClusterRadius: 60, disableClusteringAtZoom: 12 });
map.addLayer(markerClusterGroup);

// Ensure data is loaded (from IDB if present) and UI is initialized
loadDataAndInit();
// perf instrumentation removed

</script>

</body>
</html>