<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-468B94S87K"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-468B94S87K');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis of KY Road Closures: Map</title>
    <!-- My stylesheet for this page -->
    <link rel="stylesheet" href="../css/analysis_by_map.css">
    <!-- Required Leaflet CSS for mapping -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <!-- MarkerCluster plugin CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
    <!-- Required Leaflet JS for mapping -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- MarkerCluster plugin JS -->
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
</head>
<body>
    <nav class="main-nav">
        <a class="nav-link" href="../index.html">Home</a>
        <a class="nav-link" href="analysis_by_count.html">Analysis by Count</a>
        <a class="nav-link" href="analysis_by_duration.html">Analysis by Duration</a>
        <a class="nav-link" href="analysis_by_map.html">Map View</a>
        <a class="nav-link" href="analysis_by_table.html">Table View</a>
        <a class="nav-link" href="powerbi.html">Power BI Dashboard</a>
        <a class="nav-link" href="about.html">About</a>
    </nav>
    <div style="text-align: center;">
        <h1>Interactive Analysis of KY Road Closures: by Location</h1>
        <h2>Data refreshes daily 12:30am EST</h2>
    </div>


<div style="text-align: center;">
  <!-- Center filter controls to match the map width (800px) -->
  <div class="dropdown-filter-menus" style="display: inline-block; width:100%; max-width:800px;">
    <!-- Row 1: selectors inline with labels next to selects -->
    <div style="display:flex;gap:18px;align-items:center;justify-content:center;flex-wrap:wrap;margin-bottom:8px;">
      <div style="display:inline-flex;align-items:center;gap:8px;">
        <label for="yearFilterSelect" style="font-weight:bold;margin:0;">Year</label>
        <select id="yearFilterSelect" style="font-size:1.05em;padding:0.35em 0.8em;border-radius:4px;border:1px solid #ccc;min-width:120px;"></select>
      </div>
      <div style="display:inline-flex;align-items:center;gap:8px;">
        <label for="districtFilterSelect" style="font-weight:bold;margin:0;">District</label>
        <select id="districtFilterSelect" style="font-size:1.05em;padding:0.35em 0.8em;border-radius:4px;border:1px solid #ccc;min-width:110px;"></select>
      </div>
      <div style="display:inline-flex;align-items:center;gap:8px;">
        <label for="countyFilter" style="font-weight:bold;margin:0;">County</label>
        <select id="countyFilter" style="font-size:1.05em;padding:0.35em 0.8em;border-radius:4px;border:1px solid #ccc;min-width:160px;">
          <option value="">All Counties</option>
        </select>
      </div>
    </div>
    <!-- Row 2: options (centered) -->
    <div style="display:flex;align-items:center;gap:12px;justify-content:center;flex-wrap:wrap;margin-bottom:8px;">
      <label style="font-size:0.95em;display:flex;align-items:center;gap:8px;">
        <input id="enableClustering" type="checkbox"> Enable Clustering
      </label>
      <button id="refreshDataBtn" style="background:#e9f5ff;color:var(--blue);font-weight:600;border:1px solid var(--blue);padding:0.45em 1em;border-radius:6px;cursor:pointer;font-size:0.95em;">Refresh Data</button>
      <button id="clearFiltersBtn" style="background:var(--light-gray);color:var(--blue);font-weight:bold;border:none;padding:0.6em 1.2em;border-radius:6px;cursor:pointer;font-size:1.0em;box-shadow:0 2px 8px rgba(0,0,0,0.04);transition:background 0.2s;">Clear</button>
    </div>
    <script>
  // --- Dynamic Dropdowns and Map Filtering ---
  // These variables will be used by the main script as well
  let allData = [];
  let filteredData = [];

  // --- IndexedDB helpers ---
  const IDB_DB_NAME = 'roadclosures-db';
  const IDB_STORE = 'datasets';
  const IDB_KEY = 'data_v4_final_roadclosures';
  const IDB_META_KEY = 'data_v4_final_roadclosures_meta';

  function openDb() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(IDB_DB_NAME, 1);
      req.onupgradeneeded = function(e) {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(IDB_STORE)) {
          db.createObjectStore(IDB_STORE);
        }
      };
      req.onsuccess = function(e) { resolve(e.target.result); };
      req.onerror = function(e) { reject(e.target.error); };
    });
  }

  async function idbGet(key) {
    try {
      const db = await openDb();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, 'readonly');
        const store = tx.objectStore(IDB_STORE);
        const req = store.get(key);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    } catch (err) {
      return null;
    }
  }

  async function idbPut(key, value) {
    try {
      const db = await openDb();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, 'readwrite');
        const store = tx.objectStore(IDB_STORE);
        const req = store.put(value, key);
        req.onsuccess = () => resolve(true);
        req.onerror = () => reject(req.error);
      });
    } catch (err) {
      return false;
    }
  }

  async function idbDelete(key) {
    try {
      const db = await openDb();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, 'readwrite');
        const store = tx.objectStore(IDB_STORE);
        const req = store.delete(key);
        req.onsuccess = () => resolve(true);
        req.onerror = () => reject(req.error);
      });
    } catch (err) {
      return false;
    }
  }

  async function loadDataAndInit() {
    // IDB-first model with daily check for current year updates.
    const today = new Date().toISOString().slice(0,10);
    try {
      const t0 = performance.now();
      const cached = await idbGet(IDB_KEY);
      const meta = await idbGet(IDB_META_KEY);
      const idbMs = Math.round(performance.now() - t0);
      if (cached && Array.isArray(cached)) {
        // If meta indicates we've already updated today, use cache.
        const lastFetched = meta && meta.lastFetched ? meta.lastFetched : null;
        if (lastFetched === today) {
          updateDataStatus({ source: 'indexeddb', idbTime: idbMs, records: cached.length });
          console.info('Loaded from IDB (fresh):', cached.length, 'records');
          allData = cached;
          filteredData = allData;
          updateDropdowns();
          scheduleUpdateMapMarkers();
          attachFilterHandlers();
          buildLegend(getUnique(allData, item => getYear(item.Reported_On)));
          return;
        }
        // Otherwise attempt to fetch current-year updates, but still use cache if fetch fails.
        try {
          const currentYear = new Date().getFullYear().toString();
          const t1 = performance.now();
          const resp = await fetch('../data/data_v4_final_roadclosures.json');
          const data = await resp.json();
          const fetchMs = Math.round(performance.now() - t1);
          // Filter only current year records and merge dedup
          const updates = data.filter(d => getYear(d.Reported_On) === currentYear);
          // Merge updates into cached by key
          const keyMap = {};
          cached.forEach(item => {
            const key = [item.latitude, item.longitude, item.Road_Name, item.Reported_On, item.Comments].join('|');
            keyMap[key] = item;
          });
          let added = 0;
          updates.forEach(u => {
            const key = [u.latitude, u.longitude, u.Road_Name, u.Reported_On, u.Comments].join('|');
            if (!keyMap[key]) { keyMap[key] = u; added++; }
          });
          const merged = Object.values(keyMap);
          await idbPut(IDB_KEY, merged);
          await idbPut(IDB_META_KEY, { lastFetched: today });
          updateDataStatus({ source: 'indexeddb-updated', idbTime: idbMs, fetchTime: fetchMs, records: merged.length });
          console.info('Merged updates from network. added=', added, 'total=', merged.length);
          allData = merged;
          filteredData = allData;
          updateDropdowns();
          scheduleUpdateMapMarkers();
          attachFilterHandlers();
          buildLegend(getUnique(allData, item => getYear(item.Reported_On)));
          return;
        } catch (innerErr) {
          console.warn('Update fetch failed, using cached data', innerErr);
          updateDataStatus({ source: 'indexeddb-stale', idbTime: idbMs, records: cached.length });
          allData = cached;
          filteredData = allData;
          updateDropdowns();
          scheduleUpdateMapMarkers();
          attachFilterHandlers();
          buildLegend(getUnique(allData, item => getYear(item.Reported_On)));
          return;
        }
      }
      // No cached data: fetch initial dataset and populate IDB (first visit)
      const t2 = performance.now();
      const resp2 = await fetch('../data/data_v4_final_roadclosures.json');
      const data2 = await resp2.json();
      const fetchMs2 = Math.round(performance.now() - t2);
      await idbPut(IDB_KEY, data2);
      await idbPut(IDB_META_KEY, { lastFetched: today });
      updateDataStatus({ source: 'network-initial', fetchTime: fetchMs2, records: data2.length });
      console.info('Fetched initial dataset and cached to IDB:', data2.length);
      allData = data2;
      filteredData = allData;
      updateDropdowns();
      scheduleUpdateMapMarkers();
      attachFilterHandlers();
      buildLegend(getUnique(allData, item => getYear(item.Reported_On)));
      return;
    } catch (err) {
      console.error('Data initialization failed', err);
      updateDataStatus({ source: 'error', message: String(err) });
    }
  }

  function updateDataStatus(info) {
    const el = document.getElementById('dataStatus');
    if (!el) return;
    switch (info.source) {
      case 'indexeddb':
        el.textContent = `Loaded from cache: ${info.records} records (idb ${info.idbTime} ms)`; break;
      case 'indexeddb-updated':
        el.textContent = `Cache merged with updates: ${info.records} records (idb ${info.idbTime} ms, fetch ${info.fetchTime} ms)`; break;
      case 'indexeddb-stale':
        el.textContent = `Using cached (stale): ${info.records} records (idb ${info.idbTime} ms)`; break;
      case 'network-initial':
        el.textContent = `Initial fetch and cached: ${info.records} records (fetch ${info.fetchTime} ms)`; break;
      case 'network':
        el.textContent = `Fetched ${info.records} records (network ${info.fetchTime} ms)`; break;
      case 'error':
        el.textContent = `Error: ${info.message}`; break;
      default:
        el.textContent = '';
    }
  }

  function attachFilterHandlers() {
    const countyEl = document.getElementById('countyFilter');
    if (countyEl && !countyEl._attached) {
  countyEl.addEventListener('change', function(){ onFilterChange(); scheduleUpdateMapMarkers(); });
      countyEl._attached = true;
    }
    const clearBtn = document.getElementById('clearFiltersBtn');
    if (clearBtn && !clearBtn._attached) {
      clearBtn.addEventListener('click', function() {
        document.getElementById('yearFilterValue').value = '';
        document.getElementById('districtFilterValue').value = '';
        document.getElementById('countyFilter').value = '';
        filterData();
        updateDropdowns();
        scheduleUpdateMapMarkers();
      });
      clearBtn._attached = true;
    }
    const clusterToggle = document.getElementById('enableClustering');
    if (clusterToggle && !clusterToggle._attached) {
      clusterToggle.addEventListener('change', function() {
        // Re-render markers using the new clustering preference (debounced)
        scheduleUpdateMapMarkers(150);
      });
      clusterToggle._attached = true;
    }
    const yearSelect = document.getElementById('yearFilterSelect');
    if (yearSelect && !yearSelect._attached) {
      yearSelect.addEventListener('change', function() {
        document.getElementById('yearFilterValue').value = this.value || '';
        onFilterChange();
        scheduleUpdateMapMarkers();
      });
      yearSelect._attached = true;
    }
    const districtSelect = document.getElementById('districtFilterSelect');
    if (districtSelect && !districtSelect._attached) {
      districtSelect.addEventListener('change', function() {
        document.getElementById('districtFilterValue').value = this.value || '';
        onFilterChange();
        scheduleUpdateMapMarkers();
      });
      districtSelect._attached = true;
    }
    const refreshBtn = document.getElementById('refreshDataBtn');
    if (refreshBtn && !refreshBtn._attached) {
      refreshBtn.addEventListener('click', async function() {
        refreshBtn.disabled = true;
        const orig = refreshBtn.textContent;
        refreshBtn.textContent = 'Refreshing...';
        try {
          // Force fetch full dataset and cache to IDB
          const t = performance.now();
          const resp = await fetch('../data/data_v4_final_roadclosures.json');
          const data = await resp.json();
          const fetchMs = Math.round(performance.now() - t);
          await idbPut(IDB_KEY, data);
          const today = new Date().toISOString().slice(0,10);
          await idbPut(IDB_META_KEY, { lastFetched: today });
          console.info('Fetched and cached dataset to IDB:', data.length);
          updateDataStatus({ source: 'network', fetchTime: fetchMs, records: Array.isArray(data) ? data.length : 0 });
          allData = data;
          filteredData = allData;
          updateDropdowns();
          scheduleUpdateMapMarkers();
        } catch (err) {
          console.warn('Refresh failed', err);
          updateDataStatus({ source: 'error', message: String(err) });
        }
        refreshBtn.textContent = orig;
        refreshBtn.disabled = false;
      });
      refreshBtn._attached = true;
    }
  }

  // Add chunked marker addition to avoid blocking the main thread when adding many markers
  function yearColor(year) {
    const palette = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'];
    const idx = (parseInt(year,10) || 0) % palette.length;
    return palette[idx];
  }

  function chunkedAddMarkers(closures, chunkSize = 400, delay = 20) {
    // closures: array of closure objects already deduplicated
    window.nonClusterMarkers = window.nonClusterMarkers || [];
    let i = 0;
    function work() {
      const end = Math.min(i + chunkSize, closures.length);
      for (; i < end; i++) {
        const closure = closures[i];
        const lat = parseFloat(closure.latitude);
        const lon = parseFloat(closure.longitude);
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          const clusterEnabled = document.getElementById('enableClustering') && document.getElementById('enableClustering').checked;
          const content = `<b>${closure.Road_Name}</b><br>` +
            `${closure.Comments}<br>` +
            `<b>County:</b> ${closure.County_Name}<br>` +
            `<b>Reported:</b> ${closure.Reported_On}<br>` +
            `<b>Duration (hrs):</b> ${closure.Duration_Hours}`;
          if (clusterEnabled) {
            const marker = L.marker([lat, lon]);
            marker.on('click', function(e) { if (!this.getPopup()) this.bindPopup(content).openPopup(); });
            markerClusterGroup.addLayer(marker);
          } else {
            const yr = getYear(closure.Reported_On) || '0';
            const color = yearColor(yr);
            const marker = L.circleMarker([lat, lon], { radius: 5, color: '#333', weight: 1, fillColor: color, fillOpacity: 0.85 });
            marker.on('click', function(e) { if (!this.getPopup()) this.bindPopup(content).openPopup(); });
            marker.addTo(map);
            window.nonClusterMarkers.push(marker);
          }
        }
      }
      if (i < closures.length) {
        setTimeout(work, delay);
      } else {
        // finished
      }
    }
    work();
  }

  // Debounced update helper to avoid re-rendering rapidly during wheel/zoom
  let __updateTimer = null;
  function scheduleUpdateMapMarkers(delay = 200) {
    if (__updateTimer) clearTimeout(__updateTimer);
    __updateTimer = setTimeout(() => {
      updateMapMarkers();
      __updateTimer = null;
    }, delay);
  }
  // Debounced update helper to avoid re-rendering rapidly during wheel/zoom


  function getUnique(arr, keyFn) {
    return [...new Set(arr.map(keyFn))].sort();
  }

  function getYear(dateStr) {
    if (!dateStr) return '';
    const d = new Date(dateStr);
    return isNaN(d) ? '' : d.getFullYear().toString();
  }

  function buildLegend(years) {
    const container = document.getElementById('legendContainer');
    if (!container) return;
    try {
      const uniq = Array.from(new Set(years.filter(Boolean))).sort();
      container.innerHTML = '';
      uniq.forEach(y => {
        const span = document.createElement('span');
        span.style.marginRight = '10px';
        const col = yearColor(y);
        span.innerHTML = `<span style="display:inline-block;width:12px;height:12px;background:${col};margin-right:6px;border:1px solid #333;"></span>${y}`;
        container.appendChild(span);
      });
    } catch (e) { /* noop */ }
  }

  function populateDropdown(id, options, label) {
    const select = document.getElementById(id);
    // For county dropdown, show counts if id === 'countyFilter'
    if (id === 'countyFilter') {
      // Get selected year
      const selectedYear = document.getElementById('yearFilterValue') ? document.getElementById('yearFilterValue').value : '';
      // Get selected district
      const selectedDistrict = document.getElementById('districtFilterValue') ? document.getElementById('districtFilterValue').value : '';
      // Filter data by year only (not district)
      let dataForCount = allData;
      if (selectedYear) {
        dataForCount = allData.filter(item => getYear(item.Reported_On) === selectedYear);
      }
      // If district is selected, only show counties in that district
      let countyOptions = options;
      if (selectedDistrict) {
        countyOptions = getUnique(
          allData.filter(item => String(item.District_Number) === selectedDistrict),
          item => item.County_Name
        );
      }
      select.innerHTML = `<option value="">All ${label}</option>` +
        countyOptions.map(opt => {
          // Count records for this county (filtered by year only)
          const count = dataForCount.filter(item => item.County_Name === opt).length;
          return `<option value="${opt}">${opt} (${count})</option>`;
        }).join('');
    } else {
      select.innerHTML = `<option value="">All ${label}</option>` +
        options.map(opt => `<option value="${opt}">${opt}</option>`).join('');
    }
  }

  // Populate a native <select> element with options
  function populateSelect(id, options, includeAllLabel) {
    const sel = document.getElementById(id);
    if (!sel) return;
    const allLabel = includeAllLabel || 'All';
    sel.innerHTML = '';
    const first = document.createElement('option');
    first.value = '';
    first.textContent = `${allLabel}`;
    sel.appendChild(first);
    options.forEach(opt => {
      const o = document.createElement('option');
      o.value = opt;
      o.textContent = opt;
      sel.appendChild(o);
    });
  }

  function populateMenu(id, options, selected, label) {
    // Backwards-compat: if an element with this id exists and is a select, populate that instead
    const el = document.getElementById(id);
    if (!el) return;
    if (el.tagName && el.tagName.toLowerCase() === 'select') {
      populateSelect(id, options, `All ${label}`);
      // select current value if available
      if (selected) el.value = selected;
      return;
    }
    // legacy nav-menu behavior
    const menu = el;
    menu.innerHTML = '';
    // Add "All" option
    const allBtn = document.createElement('a');
    allBtn.className = 'nav-link';
    allBtn.textContent = `All ${label}`;
    allBtn.style.cursor = 'pointer';
    if (!selected) {
      allBtn.style.background = 'var(--blue)';
      allBtn.style.color = '#fff';
    }
    allBtn.onclick = function() {
      menu.querySelectorAll('.nav-link').forEach(el => {
        el.style.background = '';
        el.style.color = '';
      });
      allBtn.style.background = 'var(--blue)';
      allBtn.style.color = '#fff';
      setFilter(id, '');
    };
    menu.appendChild(allBtn);
    options.forEach(opt => {
      const btn = document.createElement('a');
      btn.className = 'nav-link';
      btn.textContent = opt;
      btn.style.cursor = 'pointer';
      if (selected == opt) {
        btn.style.background = 'var(--blue)';
        btn.style.color = '#fff';
      }
      btn.onclick = function() {
        menu.querySelectorAll('.nav-link').forEach(el => {
          el.style.background = '';
          el.style.color = '';
        });
        btn.style.background = 'var(--blue)';
        btn.style.color = '#fff';
        setFilter(id, opt);
      };
      menu.appendChild(btn);
    });
  }

  function setFilter(menuId, value) {
    if (menuId === 'yearMenu') {
      document.getElementById('yearFilterValue').value = value;
    } else if (menuId === 'districtMenu') {
      document.getElementById('districtFilterValue').value = value;
    }
    onFilterChange();
  }

  function filterData() {
    const year = document.getElementById('yearFilterValue').value;
    const district = document.getElementById('districtFilterValue').value;
    const county = document.getElementById('countyFilter').value;
    filteredData = allData.filter(item => {
      const itemYear = getYear(item.Reported_On);
      return (!year || itemYear === year) &&
             (!district || String(item.District_Number) === district) &&
             (!county || item.County_Name === county);
    });
  }

  function updateDropdowns() {
    // Always show all years and districts from allData
    const yearSet = getUnique(allData, item => getYear(item.Reported_On));
    let districtSet = getUnique(allData, item => String(item.District_Number));
    districtSet = districtSet.sort((a, b) => Number(a) - Number(b));
    // County options filtered by selected district
    const selectedDistrict = document.getElementById('districtFilterValue').value;
    let countySet;
    if (selectedDistrict) {
      countySet = getUnique(
        allData.filter(item => String(item.District_Number) === selectedDistrict),
        item => item.County_Name
      );
    } else {
      countySet = getUnique(allData, item => item.County_Name);
    }
    populateMenu('yearMenu', yearSet, document.getElementById('yearFilterValue').value, 'Years');
    populateMenu('districtMenu', districtSet, document.getElementById('districtFilterValue').value, 'Districts');
    populateDropdown('countyFilter', countySet, 'Counties');
    // Also populate new select elements if present
    try {
      populateSelect('yearFilterSelect', yearSet, 'All Years');
      const ysel = document.getElementById('yearFilterSelect'); if (ysel) ysel.value = document.getElementById('yearFilterValue').value || '';
    } catch (e) {}
    try {
      populateSelect('districtFilterSelect', districtSet, 'All Districts');
      const dsel = document.getElementById('districtFilterSelect'); if (dsel) dsel.value = document.getElementById('districtFilterValue').value || '';
    } catch (e) {}
  }

  function updateMapMarkers() {
    // clear any existing non-cluster markers and cluster group
    if (window.nonClusterMarkers && window.nonClusterMarkers.length) {
      window.nonClusterMarkers.forEach(m => { try { map.removeLayer(m); } catch(e){} });
    }
    window.nonClusterMarkers = [];
    try { markerClusterGroup.clearLayers(); } catch (e) {}
    const selectedCounty = document.getElementById('countyFilter').value;
    // Always render non-clustered colored circle markers (clustering disabled)
    // Deduplicate by lat,lon,road,reported,comments
    const usedCoords = {};
    const uniqueClosures = [];
    (selectedCounty ? filteredData.filter(item => item.County_Name === selectedCounty) : filteredData).forEach(closure => {
      if (closure.latitude && closure.longitude) {
        const key = [closure.latitude, closure.longitude, closure.Road_Name, closure.Reported_On, closure.Comments].join('|');
        if (!usedCoords[key]) { usedCoords[key] = true; uniqueClosures.push(closure); }
      }
    });
    // Build legend from available years
    buildLegend(getUnique(uniqueClosures, item => getYear(item.Reported_On)));
    // Zoom/fit to selected county extent if a county is selected
    try {
      if (selectedCounty && uniqueClosures.length > 0) {
        const bounds = L.latLngBounds(uniqueClosures.map(c => [parseFloat(c.latitude), parseFloat(c.longitude)]).filter(p => Number.isFinite(p[0]) && Number.isFinite(p[1])));
        if (bounds.isValid() && bounds.getNorthEast() && bounds.getSouthWest()) {
          if (uniqueClosures.length === 1) {
            // single point: center and zoom in moderately
            const p = bounds.getCenter();
            map.setView(p, Math.max(map.getZoom(), 12));
          } else {
            map.fitBounds(bounds.pad(0.15));
          }
        }
      } else if (!selectedCounty) {
        // no county selected: reset to default full-state view
        try { map.setView([37.822295, -85.76819], 7); } catch (e) { /* noop */ }
      }
    } catch (e) { console.warn('Error fitting bounds', e); }

  // Use chunked renderer to add markers (clustered or non-clustered depending on toggle)
  chunkedAddMarkers(uniqueClosures);
  }

  function onFilterChange(e) {
    // Save current selections
    const prev = {
      year: document.getElementById('yearFilterValue').value,
      district: document.getElementById('districtFilterValue').value,
      county: document.getElementById('countyFilter').value
    };
    filterData();
    updateDropdowns();
    // Restore previous selection if still valid
    document.getElementById('yearFilterValue').value = prev.year;
    document.getElementById('districtFilterValue').value = prev.district;
    document.getElementById('countyFilter').value = prev.county;
    filterData(); // filter again in case dropdowns changed
    updateMapMarkers();
  }

  // Wait for DOM and map to be ready
  document.addEventListener('DOMContentLoaded', function() {
    // Add hidden inputs to store selected values
    if (!document.getElementById('yearFilterValue')) {
      const y = document.createElement('input');
      y.type = 'hidden';
      y.id = 'yearFilterValue';
      y.value = '';
      document.body.appendChild(y);
    }
    if (!document.getElementById('districtFilterValue')) {
      const d = document.createElement('input');
      d.type = 'hidden';
      d.id = 'districtFilterValue';
      d.value = '';
      document.body.appendChild(d);
    }
    // Load data (try IndexedDB first, then network) and initialize the UI
    loadDataAndInit();
  });
    </script>
    </div>
</div>

    <div style="text-align: center; margin-top:8px;">
      <div id="legendContainer" style="margin-bottom:8px; max-width:800px; text-align:left; display:inline-block;"></div>
    </div>
    <div style="text-align: center;">
      <div id="map" style="width: 800px; height: 600px; display: inline-block;"></div>
    </div>
    <div style="text-align:center;margin-top:8px;font-size:0.95em;color:#333;">
      <span id="dataStatus">&nbsp;</span>
    </div>

<!-- perf panel removed -->

<script>

// Leaflet Map
// =============================
// The following Leaflet map is based on their Quick Start example.
// https://leafletjs.com/examples/quick-start/
// I just had to fetch my data and start customizing the content.
// The performance was horrible with 10,000+ individual markers
// I had to use the Leaflet.markercluster plugin.

// latitude, longitude, and zoom to center of Kentucky
const map = L.map('map').setView([37.822295, -85.76819], 7);

// Add OpenStreetMap tiles as the base map layer
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', 
{
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
}).addTo(map);

// Create marker cluster group (used when clustering enabled)
let markerClusterGroup = L.markerClusterGroup({ maxClusterRadius: 60, disableClusteringAtZoom: 12 });
map.addLayer(markerClusterGroup);

// Ensure data is loaded (from IDB if present) and UI is initialized
loadDataAndInit();
// perf instrumentation removed

</script>

</body>
</html>